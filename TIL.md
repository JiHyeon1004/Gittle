## 2022-10-11

## 오픈 소스 기여하는 방법에 대하여

- [기존 프로젝트 활용](https://www.notion.so/4fa695823c344885b149499458264e48)
- [새로운 프로젝트 시작](https://tech.osci.kr/2021/03/16/오픈소스에-기여하는-방법에-대하여-2-새로운-프로젝/)

### 1. 기존 프로젝트 활용하기

- 내가 사용 중인 오픈 소스에 대한 관심과 그것이 가진 기능 활용해 보기
- 어떤 시스템 또는 소프트웨어를 개발하려는 경우 개발하고자 하는 기능에 대한 충분한 분석 뒤, 이미 존재하는 오픈 소스 프로젝트라면 내가 원하는 요구 사항을 만족하는 것이 있는지 확인

1. **오픈 소스 프로젝트 검색 방법**

   1. 구글링
   2. 오픈 소스 저장소 내 검색

   - 예) GitHub, SourceForge, Bitbucket, Google Code 등

   1. 오픈 소스 재단 내 검색

   - 예) 아파치 재단, 리눅스 재단, 모질라 대단

   1. 그 외

   - https://www.findbestopensource.com/home
   - https://www.openhub.net/

2. **오픈 소스 프로젝트 참여**

   - 커뮤니티 활동 통한 의견 교류, 프로젝트 문서 수정 또는 번역, 한글 번역
   - 기능 등록 및 수정 요청, 패치 요청, 커미터 또는 컨트리뷰터 활동, 버그 리포트
     - 커미터(committer): 프로젝트 내 직접 코드 push 권한
     - 컨트리뷰터(contributter): 패치 등 소스 코드 제공

### 2. 새로운 프로젝트 시작하기

- 위험 요인 분석 필요
  - 새 프로젝트가 기존 프로젝트에 비해 경쟁력을 가지는지
  - 개발과 추후 관리 위한 충분한 자원자를 확보할 수 있는지
  - 개발에 필요한 장비가 확보 가능한지

1. **프로토타입 구현**

   - 고품질의 프로토타입을 완성하는 일의 중요성
   - 최초의 요구 사항이 일부 수정되고 그 결과가 설계의 변경을 필요로 함
   - 구성원 사이 의사소통과 문서화 필요
   - 오픈 소스 개발의 가장 중요한 특징인 분산 개발을 효과적으로 수행하고, 소스 코드의 재사용 가능서을 높이기 위하여 모듈화, 계층화된 소프트웨어 설계를 하는 것이 중요

   **a-1. 내부 시험의 필요성**

   - 프로토타입 배포 이전 내부 시험 필요
   - 주로 모듈 단위로 설계, 구현되는 소프트웨어 구조 때문에 오픈 소스 프로젝트에서는 기존의 라이브러리 적극적으로 활용
   - 배포 전 호환성, 가이드, 편의성 문제 해결에 많은 노력 필요
   - 다양한 빌드 도구 활용해 다른 개발자들이 손쉽게 SW를 개발하고 테스팅할 수 있는 환경 조성 필요

2. **결과물 배포**

   - BitBucket, GitHub 등의 오픈소스 프로젝트 사이트 이용
   - OSI(Open Source Initiative)의 오픈 소스 정의가 오픈 소스에 대한 명확한 가이드라인으로 사용

3. **개발자 간 의사소통**

   - 커뮤니티 참여자의 성격(개발자, 관리자, 사용자 등)에 따른 메일링 리스트
   - 포럼과 그들의 아카이브
   - 버그 리포트: 사용자와 개발자의 공식적인 통신 방법
     - 별도의 홈페이지 이용한다면 Bugzilla, Trac, Redmine, 아틀라시아의 JIRA를 버그 트래킹 시스템으로 활용
     - 버그 트래킹 시스템은 버그 등록, 담당자, 처리 상태, 의견 교환 등 버그 발생부터 해결까지 전 과정에 대한 관리 방법 제공
   - 프로젝트 관련 문서, FAQ
   - 소스 코드의 경우 배포 버전, 베타 버전(외부용 시험 버전), 소스 코드 스냅샷(현재 개발 진행 중) 3가지 모두 공개
   - 소스 코드의 공개는 오픈소스 소프트웨어의 가장 큰 미덕으로 누구나 쉽게 다운로드, 리뷰, 빌드 후 패치하여 프로젝트 관리자에게 보낼 수 있어야 함

4. **커뮤니티 기반 개발**

----

## 2022-10-12

## GITHUB 기반 온라인 코드 리뷰 방법

![Untitled](C:\Users\kiwio\AppData\Roaming\Typora\typora-user-images\image-20221012225930965.png)

1. 브랜치 생성 요청

2. fork

3. clone -b A 브랜치 —single-branch 주소

4. checkout -b 작업용 브랜치

5. local의 작업용 브랜치에서 add/commit

6. push로 remote branch에서 반영

7. pull request로 작업용 브랜치에서 A 브랜치로 코드 리뷰 요청

   피드백받으면 해당 브랜치에서 다시 작업

8. 리뷰 후 merge

9. checkout A 브랜치

10. remote add upstream 주소 (원격 저장소 추가)

    git remote -v로 원격 브랜치 확인

    - 원격 브랜치와 로컬 브랜치 확실히 구분

11. fetch upstream A 브랜치 → remote 브랜치에서 local 브랜치로 가져옴

12. rebase upstream A 브랜치 → remote 브랜치 코드 가져옴 (동기화)

13. checkout -b 작업용 브랜치 2

---

## 2022-10-13

## 오늘 한 일

1. **계획서 작성**

   - 계획서를 작성하다 보니 프로젝트의 목표, 방향성이 보다 구체적으로 바뀌었다

   - 계획서를 너무 빠르게 기재한다고 생각해서 불만이 좀 있었는데, 어떤 아이디어를 구상화하고 싶다면 문서로 먼저 특징이나 기능에 대해 정리하는 것도 괜찮은 방법 같다

   - 추가적으로 기능 명세서를 확실히 정리할 필요성을 느꼈다

   - 와이어프레임은 Figma를 보고 참고해 왔는데, 아직 구체적인 디자인이 떠오르지 않는다 조금 더 고민이 필요할 듯싶다

   - GIT 시각화를 주제로 삼은 만큼 팀원들 모두가 GIT의 사용법에 대해 완벽하게 숙지하고 있어야 할 것 같은데, 이 부분에 대해 내일 같이 이야기해 봐야 할 것 같다

     -> 서비스 개발자도 해당 서비스에 대해 잘 알지 못한다면 사용자는 더욱 더 혼란스러울 것이기 때문이다

   - 서비스 대상자를 아예 초보 개발자로 설정하는 것은 좋은 아이디어라고 본다

2. **교보재 신청서 작성**

   - 세상에는 정말 많은 강의와 교재가 있다
   - 그중에 어떤 것이 더 우리에게 잘 맞고, 이해가 잘되고, 뛰어난 것인지 선별하는 것은 상당히 힘든 일이다
   - 그래서 계획서 작성보다 교보재 신청이 더 오래 걸렸다
   - 사실 교보재 신청을 1회로 제한하는 이유를 잘 모르겠다
   - 보통 예산을 미리 정해 주고, 예산 내에서 명확한 사유가 있다면 활용은 자유롭게 하는 것으로 알고 있는데 말이다
   - 처음부터 예산 한도와 제약 사항을 명확히 밝혀 주었다면 더 좋았을 것 같다
   - 교보재 신청이 받아들여져서 프로젝트에 잘 활용되기를 바란다

----

## 2022-10-14

## 컨설턴트님 피드백

- 처음에는 주니어 대상 → 시간적으로 한정적: 나중에는 나아간 버전도
  - 아예 주니어만을 대상이라고 한정 짓기 x, 점점 나아갈 것
- 아이디어를 넘어서 코드 관련하여 품질도 신경 써야 할 것
- 오픈소스: 각종 라이브러리 패킹 해 놓은 것들 생각, 개발자들이 쓸 수 있는 도구
- 이용하는 오픈소스에 컨트리뷰트를 도전하는 것도 나쁘지 않다
- 기획이 쉽지 않겠다, **완성도**가 높아야 한다, 볼륨을 확인해야 한다
- 오픈소스를 살펴볼 사람을 정해야 한다 → 오픈소스에서 사용하는 용어 통일할 필요
  - 이게 우리 서비스에 어디까지 이용 가능한지 살펴봐야 한다
- 깃 중에서 어떤 게 기준인지? 깃헙이라고 답변
  - 관련 api나 점검 필요
- 정/부는 꼭 정해 둬야 한다 → 협업에서 오는 이로움이 있기 때문
- 서버가 꼭 2가지일 필요가 있을까?
  - 프론트 서버를 CDN
- electron → native틱하게 웹에서 돌아갈 수 있게 제공 (속도가 빠름)
- 타깃 자체를 과제로 만들어서 하나씩 역할을 정해 뒀으면 좋겠다
  - 예) 깃허브 체크할 사람, 마인드맵 체크할 사람

## 멘토님 피드백

### 단체 미팅

- 주제가 겹친다면 우리 팀만의 차별화가 필요할 것
- 누가 쓸 것인가, 어떻게 쓸 것인가에 대해 생각 → 입사 인터뷰 할 때 할 말이 많아짐
- 컨트리뷰터 포기
- Chaos monkey 참고
- 기능 구현 & 가이드는 오픈소스의 양대 산맥 → 둘 다 힘줘야 됨
  - 어떤 이유 때문에 만들었는지 설득력 있게 전달할 수 있어야 한다
- 개발자 문서 작성해 보기 → 이것 자체를 하면서 많이 정리됨
- 평가는 반별로 (확정 X)
- 서버 운영 ⇒ 가용 리소스가 두 배로 늘어난다, 할 만한 퍼포먼스가 훨씬 늘어난다
  - 프로세스적인 최적화까지 이루어진다면 +a로 효용 가치가 커진다
  - 각 영역별로 전문성을 띄기 위해 나온 MSA가 있다
- 대용량 프로젝트라면 언젠가는 MSA를 사용할 수밖에 없다 (굿)
  - 그 과정에서 얻게 되는 부산물이 많다
- EC2 두 개라고 가정 (16GB)
  - 프론트는 이중 4GB도 쓰지 못한다 / 8GB가 남는다
  - MSA를 적용하여 백으로 이동하면 이쪽만 타고 있다
  - 구성을 하려면 EC2 중 일부는 웹으로 구현, 일부는 백엔드 서버로 쓰게 될 확률이 높다
  - MSA의 목적: 포인트를 명확히 해서 어떤 요소만 빠르고 작게 배포
    - 관리 포인트가 힘들다 → 고민 필요
    - 구글링 통해 매칭
- 처음 해 보는 언어를 사용할 때? 프로그램 이용할 때? (예: 일렉트론)
  - 아무 생각 않고 각 잡고 앉아서 공식 홈페이지에 있는 설명 읽고 코드 다 짜 보기
  - 6기에서도 4주 만에 진행해서 2등까지 한 사례 있음

------

### 개인 팀 미팅

- **MSA**

  - MSA 배경: Service Oriented Arcitecture의 부산물
  - MSA의 기본

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3fafad07-aff9-4ef6-9655-f5fafead4de4/Untitled.png)

  - EC2의 제약 때문에 실제로 구현하기는 힘듦, 해 봐야 DB 두 개 정도

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fb614989-307a-4963-a064-9a54ba100cdb/Untitled.png)

  - BFF: Back For Front
  - 설계: 서버가 바라보는 DB
  - 각각 바라보는 DB가있어야 한다

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2417026a-ea0b-4109-b570-3db5f1f099f7/Untitled.png)

  - 스프링 부트의 비즈니스 로직과 몹시 유사하다

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e0d2a693-9b24-4328-be4a-2ca2e1e02c36/Untitled.png)

  - 복잡하고 제약 사항이 많다

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/19d71a08-8df8-4fd8-82a7-139034cc43c9/Untitled.png)

  - 복잡성의 문제와 항상 직면하게 될 것
  - 인공신경망의 모습과 유사하다

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/24330b88-1819-433a-9fc1-3bd018a61fe5/Untitled.png)

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7447fea9-8b27-4ae0-91be-efc33e1fd8c4/Untitled.png)

  - MSA 프로젝트에는 Kafka가 필수적으로 사용됨
  - 직면하는 두 번째 이슈: EC2 서버의 가용 메모리 부족
  - 어떻게 연결되고 기능적으로 가능한지 뽑아서 진행
  - 애자일, TDD, DDD, 서킷 브레이커

- Automation 필요

- JPA, History 조회, 마우스 우클릭 시 메뉴가 등장하고 CLI

  - 명령어를 미리 만들어 놓고 사용자는 프로세스를 쉽게 이용할 수 있도록 → 스텝을 줄이는 방향, 부분 자동화, 버튼 클릭으로 해결
  - 소스트리 api 가져다 쓰기 ^^

- 데스크톱 앱: 코틀린 네이티브, 리액트 네이티브, 플러터(어려움), 일렉트론(가장 쉽다)

- 아키텍처 구현: 6주 안에 가능? / 5주 만에 한 팀은 있다~ ㅎㅎ

- 지금 해 보기~

- GIT 시각화 → 정말 핵심적인 기능이 하나 있어야 함

  - 이 주제만으로 힘이 좀 약함

  1. 누가 봐도 예쁘게  2. 기능적으로 정말 편리하게  3. 어떤 새롭고 특별한 기능을

- 오픈소스 프로그램들 정리해서 장점 취합, 섞어 보기

- 버튼으로도 기능 구현이 가능하지만 CLI도 함께 보여 줘서 교육 용도로 기능을 특화하고 싶다

  - 개발자들을 위한 오픈 소스
  - 우리 서비스가 정상적으로 돌고 있다는 것을 보여 주기 위해 CLI나 동작 로그를 제시하는 게 좋다

## 해야 할 일

1. 콘셉트를 주니어 대상으로 확실히 → 주니어들이 어떻게 쉽게 접근할 수 있을지
2. 웹 vs 프로그램 → 함께 고민
3. GIT에 대해 잘 알아야 한다
   1. 여유가 있을 때 GIT 책 읽어 보시고, 강의 보시면서 GIT 완벽히 이해
   2. 어떤 기능이 필요할지, 어떤 기술이 필요할지
4. 깃 관련 오픈소스가 많다
   1. 깃 관련 오픈소스들 종류
      1. 깃헙 데스크탑, 소스트리 → 6명 모두
      2. 깃크라켄 → 김소현
      3. 스마트깃 → 이선호, 정지현
      4. 깃콜라 →  김정현
      5. 깃포스 → 정유송
      6. Gitg → 허상
   2. 어떤 기능 참고할 수 있고, 어떤 코드 가져올 수 있는지
   3. 장단점 이거는 가져오고, 이거는 우리가 고치자
5. 틈틈이 Figma에 틀 만들어 놓기
6. Figma UI/UX 참고할 것 있으면 링크랑 캡처
7. GIT BASH → GIT 자체
   - 버튼에 action을 줘서 키워드와 명령어를 자동으로 GIT BASH에 넣어서 로딩해 주는 형태로 생각
   - GIT BASH에 타이핑을 해 줘서 하는?
8. 서버 여러 개 굴리는 일에 대해서도 조사
   1. 서버 쪽 공부 → MSA
9. 머지 & 푸시 → 드래그 앤 드롭 (좋은 의견)
10. 오류가 발생할 경우 버튼을 통해 해결 방안 몇 가지 제시
    1. 제안한 버튼을 클릭 시 입력이 되어서 진행되도록

# GIT 공부

## 깃의 쓰임새

### 1. 버전 관리

- 문서 수정 시 언제 수정했는지, 어떤 것을 변경했는지 편하고 구체적으로 기록하기 위한 버전 관리 시스템

### 2. 백업하기

- 현재 컴퓨터에 있는 자료를 다른 컴퓨터에 복제
- 깃의 원격 저장소, 온라인 저장소 → 깃허브

### 3. 협업하기

- 여러 사람이 함께 일할 수 있다
- 누가 어느 부분을 어떻게 수정했는지 기록이 남아서 나중에 오류가 생겼을 시 파악하기 쉽다

## 깃 프로그램 종류

- 깃을 편리하게 사용할 수 있도록 하는 프로그램 (=깃 클라이언트 프로그램)

### 깃 데스크탑

- 복잡한 깃 사용법을 GUI로 구현
- 장점: 사용이 쉬워서 누구나 배울 수 있음
- 단점: 기본적인 기능 위주여서 고급 사용자에게는 아쉬움

### 토터스깃

- 윈도우 전용 프로그램

### 소스트리

- 깃 기본 기능부터 고급 기능까지 사용 가능
- 기능이 많아 사용법 복잡하지만 익숙해지면 자유롭게 활용 가능

## 커맨드 라인 인터페이스 (CLI)

- 터미널 안에 직접 명령 이용해 사용하는 방식
- 기본적인 리눅스 명령+깃 명령 알아야 해서 더 어렵다